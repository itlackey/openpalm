name: Publish Docker images

# Releases are controlled via version tags:
#   v*                    → platform release  (all images)
#   assistant/v*      → single component release
#   gateway/v*            → single component release
#   admin/v*              → single component release
#   channel-chat/v*       → single component release
#   channel-discord/v*    → single component release
#   channel-voice/v*      → single component release
#   channel-telegram/v*   → single component release
#
# Manual dispatch accepts a version string and optional component filter.
# Registry changes (registry/*.json) NEVER trigger this workflow.

on:
  push:
    tags:
      - "v*"
      - "assistant/v*"
      - "gateway/v*"
      - "admin/v*"
      - "channel-chat/v*"
      - "channel-discord/v*"
      - "channel-voice/v*"
      - "channel-telegram/v*"

  workflow_dispatch:
    inputs:
      version:
        description: "Release version (must start with v, e.g. v1.2.0)"
        required: true
        type: string
      component:
        description: "Component to publish (leave empty for all)"
        required: false
        type: choice
        default: "all"
        options:
          - all
          - assistant
          - gateway
          - admin
          - channel-chat
          - channel-discord
          - channel-voice
          - channel-telegram

concurrency:
  group: publish-images-${{ github.ref }}
  cancel-in-progress: false

jobs:
  # -----------------------------------------------------------------------
  # Determine which images to build and the version tag to apply.
  # Outputs a JSON matrix consumed by the publish job.
  # -----------------------------------------------------------------------
  prepare:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      matrix: ${{ steps.matrix.outputs.result }}
      version_tag: ${{ steps.resolve.outputs.tag }}
      images: ${{ steps.matrix.outputs.images }}
    steps:
      - name: Resolve version tag and component
        id: resolve
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            TAG="${{ github.event.inputs.version }}"
            COMPONENT="${{ github.event.inputs.component }}"
          else
            REF="${{ github.ref_name }}"
            # Check if it's a component-specific tag (contains /)
            if echo "${REF}" | grep -q '/'; then
              COMPONENT="${REF%%/v*}"
              TAG="${REF#*/}"
            else
              COMPONENT="all"
              TAG="${REF}"
            fi
          fi

          if ! echo "${TAG}" | grep -qE '^v'; then
            echo "::error::Version tag must start with 'v', got: ${TAG}"
            exit 1
          fi

          echo "tag=${TAG}" >> "$GITHUB_OUTPUT"
          echo "component=${COMPONENT}" >> "$GITHUB_OUTPUT"
          echo "Version: ${TAG}, Component: ${COMPONENT}"

      - name: Build matrix
        id: matrix
        run: |
          COMPONENT="${{ steps.resolve.outputs.component }}"

          # Full list of images with their build contexts and Dockerfile paths.
          # Components that copy from packages/lib (outside their own dir) use
          # the repo root as context so all paths are accessible.
          ALL_IMAGES='[
            {"image":"assistant","context":"./assistant","file":"./assistant/Dockerfile"},
            {"image":"gateway","context":".","file":"./gateway/Dockerfile"},
            {"image":"admin","context":".","file":"./admin/Dockerfile"},
            {"image":"channel-chat","context":".","file":"./channels/chat/Dockerfile"},
            {"image":"channel-discord","context":".","file":"./channels/discord/Dockerfile"},
            {"image":"channel-voice","context":".","file":"./channels/voice/Dockerfile"},
            {"image":"channel-telegram","context":".","file":"./channels/telegram/Dockerfile"}
          ]'

          if [ "${COMPONENT}" = "all" ]; then
            FILTERED="${ALL_IMAGES}"
          else
            FILTERED=$(echo "${ALL_IMAGES}" | jq -c "[.[] | select(.image == \"${COMPONENT}\")]")
          fi

          # Expand each image into two entries (amd64 + arm64)
          MATRIX=$(echo "${FILTERED}" | jq -c '{include: [.[] | . as $base | ("amd64","arm64") as $arch | {image: $base.image, context: $base.context, file: $base.file, platform: ("linux/" + $arch), arch: $arch}]}')

          # Also output just the unique image names for the manifest job
          IMAGES=$(echo "${FILTERED}" | jq -c '[.[].image]')

          echo "result=${MATRIX}" >> "$GITHUB_OUTPUT"
          echo "images=${IMAGES}" >> "$GITHUB_OUTPUT"
          echo "Matrix: ${MATRIX}"
          echo "Images: ${IMAGES}"

  # -----------------------------------------------------------------------
  # Build and push per-arch images
  # -----------------------------------------------------------------------
  publish:
    needs: prepare
    runs-on: ubuntu-latest
    timeout-minutes: 45
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.prepare.outputs.matrix) }}
    permissions:
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ vars.DOCKERHUB_NAMESPACE || 'openpalm' }}/${{ matrix.image }}
          flavor: |
            suffix=-${{ matrix.arch }}
          tags: |
            type=raw,value=latest
            type=raw,value=${{ needs.prepare.outputs.version_tag }}
            type=sha

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: ${{ matrix.context }}
          file: ${{ matrix.file }}
          push: true
          platforms: ${{ matrix.platform }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

  # -----------------------------------------------------------------------
  # Create multi-arch manifests (latest + version tag)
  # -----------------------------------------------------------------------
  publish-manifests:
    needs: [prepare, publish]
    runs-on: ubuntu-latest
    timeout-minutes: 10
    strategy:
      matrix:
        image: ${{ fromJson(needs.prepare.outputs.images) }}
    permissions:
      contents: read
    steps:
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Create latest manifest
        run: |
          IMAGE="${{ vars.DOCKERHUB_NAMESPACE || 'openpalm' }}/${{ matrix.image }}"
          docker buildx imagetools create \
            -t "${IMAGE}:latest" \
            "${IMAGE}:latest-amd64" \
            "${IMAGE}:latest-arm64"

      - name: Create version manifest
        run: |
          IMAGE="${{ vars.DOCKERHUB_NAMESPACE || 'openpalm' }}/${{ matrix.image }}"
          TAG="${{ needs.prepare.outputs.version_tag }}"
          docker buildx imagetools create \
            -t "${IMAGE}:${TAG}" \
            "${IMAGE}:${TAG}-amd64" \
            "${IMAGE}:${TAG}-arm64"

      - name: Verify manifest architectures
        run: |
          IMAGE="${{ vars.DOCKERHUB_NAMESPACE || 'openpalm' }}/${{ matrix.image }}"
          TAG="${{ needs.prepare.outputs.version_tag }}"
          echo "Verifying ${IMAGE}:${TAG}..."
          INSPECT=$(docker buildx imagetools inspect "${IMAGE}:${TAG}" 2>&1)
          echo "$INSPECT"
          if ! echo "$INSPECT" | grep -q "linux/amd64"; then
            echo "::error::Missing linux/amd64 in manifest for ${IMAGE}:${TAG}"
            exit 1
          fi
          if ! echo "$INSPECT" | grep -q "linux/arm64"; then
            echo "::error::Missing linux/arm64 in manifest for ${IMAGE}:${TAG}"
            exit 1
          fi
          echo "Manifest verified: both architectures present."
