name: Update Registry Index

# Runs when extension registry entries are added or modified.
# Regenerates packages/lib/src/embedded/state/registry/index.json from the individual *.json entry files.
# This workflow does NOT trigger the Docker image build.

on:
  push:
    branches: [main]
    paths:
      - "packages/lib/src/embedded/state/registry/*.json"
      - "!packages/lib/src/embedded/state/registry/index.json"

jobs:
  rebuild-index:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate entries against schema
        run: |
          # Collect all entry files (exclude index.json and schema.json)
          ENTRY_FILES=$(find packages/lib/src/embedded/state/registry -maxdepth 1 -name "*.json" \
            ! -name "index.json" ! -name "schema.json" | sort)

          ERRORS=0
          for f in $ENTRY_FILES; do
            echo "Validating $f ..."
            # Basic structural check — ensure it parses as JSON object with required fields
            MISSING=$(jq -r '
              [ "id","name","description","category","risk","author",
                "version","source","tags","permissions","securityNotes",
                "installAction","installTarget" ]
              | map(select(. as $k | input? | has($k) | not))
              | if length > 0 then "Missing fields: " + join(", ") else empty end
            ' "$f" || echo "jq validation query failed for $f")

            if ! jq empty "$f" 2>/dev/null; then
              echo "  ERROR: $f is not valid JSON"
              ERRORS=$((ERRORS + 1))
            elif [ -n "$MISSING" ]; then
              echo "  ERROR: $f — $MISSING"
              ERRORS=$((ERRORS + 1))
            else
              echo "  OK"
            fi
          done

          if [ "$ERRORS" -gt 0 ]; then
            echo "Validation failed with $ERRORS error(s). Aborting index rebuild."
            exit 1
          fi

      - name: Rebuild index.json
        run: |
          ENTRY_FILES=$(find packages/lib/src/embedded/state/registry -maxdepth 1 -name "*.json" \
            ! -name "index.json" ! -name "schema.json" | sort)

          if [ -z "$ENTRY_FILES" ]; then
            echo "[]" > packages/lib/src/embedded/state/registry/index.json
            echo "No entries found — wrote empty index."
          else
            # Combine all entry objects into a JSON array
            jq -s '.' $ENTRY_FILES > packages/lib/src/embedded/state/registry/index.json
            COUNT=$(jq length packages/lib/src/embedded/state/registry/index.json)
            echo "Wrote $COUNT entries to packages/lib/src/embedded/state/registry/index.json"
          fi

      - name: Validate rebuilt index
        run: |
          if ! jq empty packages/lib/src/embedded/state/registry/index.json; then
            echo "::error::Generated index.json is not valid JSON"
            exit 1
          fi
          COUNT=$(jq length packages/lib/src/embedded/state/registry/index.json)
          echo "Index contains $COUNT entries"
          if [ "$COUNT" -eq 0 ] && [ -n "$(find packages/lib/src/embedded/state/registry -maxdepth 1 -name '*.json' ! -name index.json ! -name schema.json)" ]; then
            echo "::error::Index is empty but entry files exist"
            exit 1
          fi

      - name: Commit and push updated index
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add packages/lib/src/embedded/state/registry/index.json
          if git diff --cached --quiet; then
            echo "index.json is already up to date — nothing to commit."
          else
            git commit -m "chore: regenerate packages/lib/src/embedded/state/registry/index.json [skip ci]"
            for attempt in 1 2 3; do
              git push && break
              echo "::warning::Push failed, retrying in $((2 ** attempt))s..."
              sleep $((2 ** attempt))
            done
          fi
